import { LIGOFlavors } from '../../../modules/ligo';

// Contract code is stolen from https://ligolang.org homepage examples
const src = {
  [LIGOFlavors.PascaLIGO]: {
    extension: "ligo",
    code: "type storage is int\n\ntype parameter is\n  Increment of int\n| Decrement of int\n| Reset\n\ntype return is list (operation) * storage\n\n// Two entrypoints\n\nfunction add (const store : storage; const delta : int) : storage is \n  store + delta\n\nfunction sub (const store : storage; const delta : int) : storage is \n  store - delta\n\n(* Main access point that dispatches to the entrypoints according to\n   the smart contract parameter. *)\n\nfunction main (const action : parameter; const store : storage) : return is\n ((nil : list (operation)),    // No operations\n  case action of [\n    Increment (n) -> add (store, n)\n  | Decrement (n) -> sub (store, n)\n  | Reset         -> 0\n  ])\n\n(* Tests for main access point *)\n\nconst test_initial_storage =\n  block {\n    const initial_storage = 42;\n    const (taddr, _, _) = Test.originate(main, initial_storage, 0tez);\n    const storage = Test.get_storage(taddr);\n  } with (storage = initial_storage);\n\nconst test_increment =\n  block {\n    const initial_storage = 42;\n    const (taddr, _, _) = Test.originate(main, initial_storage, 0tez);\n    const contr = Test.to_contract(taddr);\n    const _ = Test.transfer_to_contract_exn(contr, Increment(1), 1mutez);\n    const storage = Test.get_storage(taddr);\n  } with (storage = initial_storage + 1);\n",
  },
  [LIGOFlavors.CameLIGO]: {
    extension: "mligo",
    code: "type storage = int\n\ntype parameter =\n  Increment of int\n| Decrement of int\n| Reset\n\ntype return = operation list * storage\n\n// Two entrypoints\n\nlet add (store, delta : storage * int) : storage = store + delta\nlet sub (store, delta : storage * int) : storage = store - delta\n\n(* Main access point that dispatches to the entrypoints according to\n   the smart contract parameter. *)\n\nlet main (action, store : parameter * storage) : return =\n ([] : operation list),    // No operations\n (match action with\n   Increment (n) -> add (store, n)\n | Decrement (n) -> sub (store, n)\n | Reset         -> 0)\n\n(* Tests for main access point *)\n\nlet test_initial_storage =\n let initial_storage = 42 in\n let (taddr, _, _) = Test.originate main initial_storage 0tez in\n assert (Test.get_storage taddr = initial_storage)\n\nlet test_increment =\n let initial_storage = 42 in\n let (taddr, _, _) = Test.originate main initial_storage 0tez in\n let contr = Test.to_contract taddr in\n let _ = Test.transfer_to_contract_exn contr (Increment (1)) 1mutez in\n assert (Test.get_storage taddr = initial_storage + 1)\n",
  },
  [LIGOFlavors.ReasonLIGO]: {
    extension: "religo",
    code: "type storage = int;\n\ntype parameter =\n  Increment (int)\n| Decrement (int)\n| Reset;\n\ntype return = (list (operation), storage);\n\n// Two entrypoints\n\nlet add = ((store, delta) : (storage, int)) : storage => store + delta;\nlet sub = ((store, delta) : (storage, int)) : storage => store - delta;\n\n/* Main access point that dispatches to the entrypoints according to\n   the smart contract parameter. */\n\nlet main = ((action, store) : (parameter, storage)) : return => {\n (([] : list (operation)),    // No operations\n (switch (action) {\n  | Increment (n) => add ((store, n))\n  | Decrement (n) => sub ((store, n))\n  | Reset         => 0}))\n};\n\n/* Tests for main access point */\n\nlet test_initial_storage = {\n  let initial_storage = 42;\n  let (taddr, _, _) = Test.originate(main, initial_storage, 0tez);\n  assert (Test.get_storage(taddr) == initial_storage)\n};\n\nlet test_increment = {\n  let initial_storage = 42;\n  let (taddr, _, _) = Test.originate(main, initial_storage, 0tez);\n  let contr = Test.to_contract(taddr);\n  let _ = Test.transfer_to_contract_exn(contr, (Increment (1)), 1mutez);\n  assert (Test.get_storage(taddr) == initial_storage + 1)\n};\n",
  },
  [LIGOFlavors.JsLIGO]: {
    extension: "jsligo",
    code: 'type storage = int;\n\ntype parameter =\n| ["Increment", int]\n| ["Decrement", int]\n| ["Reset"];\n\ntype return_ = [list <operation>, storage];\n\n/* Two entrypoints */\n\nlet add = ([store, delta] : [storage, int]) : storage => store + delta;\nlet sub = ([store, delta] : [storage, int]) : storage => store - delta;\n\n/* Main access point that dispatches to the entrypoints according to\n   the smart contract parameter. */\n\nlet main = ([action, store] : [parameter, storage]) : return_ => {\n return [\n   (list([]) as list <operation>),    // No operations\n   (match (action, {\n    Increment: (n: int) => add ([store, n]),\n    Decrement: (n: int) => sub ([store, n]),\n    Reset:     ()  => 0}))\n  ]\n};\n\n/* Tests for main access point */\n\nlet _test_initial_storage = () : bool => {\n  let initial_storage = 42 as int;\n  let [taddr, _, _] = Test.originate(main, initial_storage, 0 as tez);\n  return (Test.get_storage(taddr) == initial_storage);\n};\n\nlet test_initial_storage = _test_initial_storage();\n\nlet _test_increment = () : bool => {\n  let initial_storage = 42 as int;\n  let [taddr, _, _] = Test.originate(main, initial_storage, 0 as tez);\n  let contr = Test.to_contract(taddr);\n  let r = Test.transfer_to_contract_exn(contr, (Increment (1)), 1 as mutez);\n  return (Test.get_storage(taddr) == initial_storage + 1);\n}\n\nlet test_increment = _test_increment();\n',
  }
}

export const makeContractFile = (flavor: LIGOFlavors) => src[flavor].code;
export const getContractFileName = (flavor: LIGOFlavors, name: string) => `${name}.${src[flavor].extension}`;
